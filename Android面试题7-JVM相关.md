1. 介绍一下Class文件
2. Java虚拟机运行时的数据区
3. 双亲委派模型

# 介绍一下Class文件

Java诞生之初，Java的规范就拆分为Java语言规范和Java虚拟机规范，为了实现Java语言的平台无关性，各种不同平台的虚拟机都统一使用的程序存储格式，也就是字节码。使用Java编译器可以把Java代码编译成为存储字节码的Class文件。Class文件是一组以8个字节为基础单位的二进制流，每一个Class文件都对应着唯一一个类或接口的定义信息。

# Java虚拟机运行时的数据区

分为 **程序计数器**，**Java虚拟机栈**，**本地方法栈**，**Java堆**，**方法区**

**程序计数器**是线程私有的一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个Java方法，那么计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是Natvie方法，这个计数器值为空。

**Java虚拟机栈**线程私有，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型。每个方法执行的同时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。方法的调用和执行完成，就对应着栈帧的入栈和岀栈过程。其中局部变量表存放的是编译器可知的各种基本数据类型，对象引用和returnAddress类型。这里规定了两种异常情况，如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverFlow异常；如果虚拟机栈可以动态扩展，并且扩展时无法申请到足够的内存，会抛出OutOfMemoryError。

**本地方法栈**与Java虚拟机栈类似，区别就是这里执行的是native方法。

**Java堆** 是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域。此内存区域的唯一目的就是存放对象实例，几乎所有的对象是你都在这里分配内存。这里也是垃圾收集器管理的主要区域，也成做GC堆。由于现代收集器基本都采用分代算法，所以Java堆还可以细分为：新生代和老年代。Java堆可以是物理上不连续的内存空间，只要逻辑连续即可。如果Java堆中没有内存完成实例分配，并且堆也无法拓展时，将抛出OutOfMemiryError。

**方法区** 也是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等。其中**运行时常量池**是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。当方法区无法满足内存分配需求时，将会抛出OutOfMemiryError。

# 双亲委派模型

双亲委派模型指的是Java虚拟机执行类加载的时候，设计的一套类加载器的加载模型。
Java虚拟机把描述类的class文件加载到内存,并对数据进行校验，转换解析和初始化，最终形成被虚拟机直接使用的Java类型，就是虚拟机的类加载机制。
从Java虚拟机的角度，存在两种不同的类加载器，一种是启动类加载器，由C++语言实现，是虚拟机的一部分。另一类是其他类加载器，由Java语言实现，独立于虚拟机外部，继承自ClassLoader抽象类。
类加载器存在层次关系，最高层是启动类加载器，然后由上到下是扩展类加载器，应用程序类加载器以及各种自定义的类加载器。双亲委派模型的工作流程是，如果一个类加载器收到了类加载的请求，它首先不会自动去尝试加载这个类，而是把这个请求委派给父类加载器去完成。只有当父类加载器反馈自己无法完成这个加载请求时，子类加载器才会尝试自己去加载。