线程进程类问题
1.	线程和进程的区别
2.	线程间通信
3.	handler机制, Looper里面消息队列如何实现
4.	如何保证多线程持有同一变量互相不影响
5.	进程间通信

# 线程和进程的区别

简单来说，进程是资源分配的最小单位，线程是CPU调度的最小单位。从计算机的角度，进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。

因为CPU的处理速度远远快于寄存器，RAM等设备，所以多个任务执行的时候，是把CPU的时间分割成时间片，来轮流处理程序。对于程序而言，相关的资源被称作为程序的上下文，当程序执行结束，或者分配的CPU执行时间用完了，那它就要被切换出去。在切换出去的最后一步工作就是保存程序的上下文，等待下一次被CPU处理。

总结起来所有的任务都是一个个被执行的，轮流的方法就是先加载程序A的上下文，再执行程序A，保存程序A的上下文。加载下一个程序B的上下文...

基于这样的背景，线程和进程的概念就出来了。他们是对应的CPU时间段的描述。进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文。而线程是什么呢？进程的颗粒度太大，每次都要有上下文的调入，保存，调出。我们可以讲进程对应的整个程序拆分成多个块，CPU执行程序的时候，分别执行这些小块程序。也就是说，线程是共享了进程的上下文环境的更为细小的CPU时间段。

# 线程间通信

* 主要推荐Handler机制
* 广播
* 共享内存
* 文件/数据库
* 传统的java技术，例如java.io包的管道，Object的信号量等,BlockingQueue阻塞队列等。

# Handler机制

Android的Handler机制是Android中进行线程间通信的最核心方法。Android系统中为Java层和Native层分别设计了对称的几个角色，Looper，Handler，Message，MessageQueue。

Android系统中将通信的消息封装成**Message**对象,并且配备有专门的**Handler**去做事件的处理。而**Message**存放在一个叫**MessageQueue**的消息队列当中被分发处理的，而保证消息队列中消息不断被分发出去，正是**Looper**对象所做的事。

其中主线程默认开始looper，是可以直接使用Handler的。而一般的Java线程中，只有开启了线程Looper,通过调用Looper.prepare()和Looper.loop()开启内部消息队列的循环。

当读到消息时，会分发给对应的Handler去做处理。而MessageQueue本身在没有消息的时候，通过阻塞队列的方式，来实现消息的等待。

在Java层的消息队列代码里，next()方法和enqueueMessage()方法最后都会调用到natvie的pollOnce()和wake()方法，而这两个方法都是通过Linux的epoll模型来实现的。pollOnce() 通过等待被激活，然后从消息队列中获取消息。wake()方法则是激活处于等待状态的消息队列，通知它有消息到达了。

## 主线程的死循环一直运行是不是特别消耗CPU资源呢？

并不是，这里就涉及到Linux pipe/epoll机制，简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质是同步I/O，即读写是阻塞的。所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。

# 如何保证多线程持有同一变量互相不影响

在Java中，可以通过ThreadLocal来实现。ThreadLocal来也就是线程局部变量，为每一个使用该变量的线程都提供一个变量值的副本，每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。从线程的角度看，

在ThreadLocal类中有一个Map，用于存储每一个线程的变量的副本。概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。

# 进程间通信

最简单的方式是基于Bundle进行数据传递。因为四大组件中的三个Activity,Service,Broadcast都可以传递Bundle格式的数据。
四大组件中，Broadcast和ContentProvider都可以进行进程间通信。
在Android中，最重要的IPC机制也就是Binder，基于Binder封装的Messanger(信使)和AIDL也是常用的可以实现IPC通信的方法。
此外，文件共享，Socket, Linux的命名管道，共享内容，信号量等方式也可以。

AIDL是(Android Interface Definition Language)安卓接口定义语言的简称，我们可以利用它定义客户端与服务使用IPC进行通信时的接口，本质上AIDL是用来快速实现Binder的工具。

Binder是Android系统提供的一种IPC机制。Binder通信采用C/S架构,从进程的角度，客户端和服务端都有用自己独立的进程用户空间，并共享内核空间，跨进程机制便是利用可共享的内存空间来完成底层通信的。

从组件角度，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。而客户端和服务端进行通信，可以简单的概括为三步：1.注册服务，服务端注册服务前到ServiceManager中。2. 获取服务，客户端使用某个服务前，先向ServiceManager那里获取到相应的服务。 3. 使用服务，客户端再根据得到的服务信息，建立与服务端所在的服务端进程的通路，从而实现通信。